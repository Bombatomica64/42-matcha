const fs = require('fs');
const path = require('path');
const YAML = require('yamljs');

/**
 * Generates validation schemas from OpenAPI specification
 * This script creates TypeScript interfaces and validation schemas
 * that can be used in your backend application
 */

function generateValidators() {
  try {
    // Read the main OpenAPI file
    const openApiPath = path.join(__dirname, '..', 'openapi.yaml');
    const openApiSpec = YAML.load(openApiPath);
    
    if (!openApiSpec) {
      throw new Error('Failed to load OpenAPI specification');
    }

    console.log('ðŸ“– Reading OpenAPI specification...');
    
    // Read external schema files
    const authSchemaPath = path.join(__dirname, '..', 'schemas', 'auth.yaml');
    const authSchema = YAML.load(authSchemaPath);
    
    // Create output directory if it doesn't exist
    const outputDir = path.join(__dirname, '..', 'generated', 'backend');
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Generate TypeScript interfaces
    let tsContent = `// Auto-generated TypeScript interfaces from OpenAPI specification
// Do not edit this file manually

export interface ApiResponse<T = any> {
  data?: T;
  message?: string;
  error?: string;
}

`;

    // Process schemas from auth.yaml
    if (authSchema && authSchema.components && authSchema.components.schemas) {
      console.log('ðŸ”§ Generating TypeScript interfaces from auth schemas...');
      
      Object.entries(authSchema.components.schemas).forEach(([schemaName, schema]) => {
        tsContent += generateTypeScriptInterface(schemaName, schema);
      });
    }

    // Process components/schemas from main file if they exist
    if (openApiSpec.components && openApiSpec.components.schemas) {
      console.log('ðŸ”§ Generating TypeScript interfaces from main schemas...');
      
      Object.entries(openApiSpec.components.schemas).forEach(([schemaName, schema]) => {
        if (schema.$ref) {
          // Skip external references as we've already processed them
          return;
        }
        
        tsContent += generateTypeScriptInterface(schemaName, schema);
      });
    }

    // Write TypeScript interfaces file
    const tsOutputPath = path.join(outputDir, 'types.ts');
    fs.writeFileSync(tsOutputPath, tsContent);
    console.log(`âœ… TypeScript interfaces generated: ${tsOutputPath}`);

    // Generate validation schemas (basic structure)
    let validationContent = `// Auto-generated validation schemas from OpenAPI specification
// Do not edit this file manually

/**
 * Basic validation functions
 * You can extend these with libraries like Joi, Yup, or Zod
 */

export const ValidationSchemas = {
  // Add your validation logic here
  validateEmail: (email: string): boolean => {
    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;
    return emailRegex.test(email);
  },

  validatePassword: (password: string): boolean => {
    // At least 8 characters, 1 uppercase, 1 lowercase, 1 number
    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d@$!%*?&]{8,}$/;
    return passwordRegex.test(password);
  },

  validateUsername: (username: string): boolean => {
    // 3-20 characters, alphanumeric and underscore only
    const usernameRegex = /^[a-zA-Z0-9_]{3,20}$/;
    return usernameRegex.test(username);
  }
};

export default ValidationSchemas;
`;

    // Write validation schemas file
    const validationOutputPath = path.join(outputDir, 'validators.ts');
    fs.writeFileSync(validationOutputPath, validationContent);
    console.log(`âœ… Validation schemas generated: ${validationOutputPath}`);

    console.log('ðŸŽ‰ Backend generation completed successfully!');
    
  } catch (error) {
    console.error('âŒ Error generating backend files:', error.message);
    process.exit(1);
  }
}

function generateTypeScriptInterface(name, schema) {
  let content = `export interface ${name} {\n`;
  
  if (schema.properties) {
    Object.entries(schema.properties).forEach(([propName, propSchema]) => {
      const isRequired = schema.required && schema.required.includes(propName);
      const optional = isRequired ? '' : '?';
      const type = mapOpenApiTypeToTS(propSchema);
      
      content += `  ${propName}${optional}: ${type};\n`;
    });
  }
  
  content += `}\n\n`;
  return content;
}

function mapOpenApiTypeToTS(schema) {
  if (schema.$ref) {
    // Extract the type name from the reference
    const refParts = schema.$ref.split('/');
    return refParts[refParts.length - 1];
  }
  
  switch (schema.type) {
    case 'string':
      if (schema.enum) {
        return schema.enum.map(val => `'${val}'`).join(' | ');
      }
      return 'string';
    case 'number':
    case 'integer':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'array':
      const itemType = schema.items ? mapOpenApiTypeToTS(schema.items) : 'any';
      return `${itemType}[]`;
    case 'object':
      if (schema.properties) {
        // Inline object type
        let objType = '{\n';
        Object.entries(schema.properties).forEach(([propName, propSchema]) => {
          const type = mapOpenApiTypeToTS(propSchema);
          objType += `    ${propName}: ${type};\n`;
        });
        objType += '  }';
        return objType;
      }
      return 'object';
    default:
      return 'any';
  }
}

// Run the generator
generateValidators();
